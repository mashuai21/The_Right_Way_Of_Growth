

> ### 数组的定义
> 
> 在计算机科学中，数组可以被定义为**一组被保存在连续存储空间中，并且具有相同类型的数据元素集合**。而数组中的每一个元素都可以通过自身的索引（Index）来进行访问。


## 一维数组
下面是用go语言定义了一个拥有5个int元素的数组：
```golang
  var a [5]int
  
	fmt.Printf("%p\n", &a)
	fmt.Printf("%p\n",  &a[0])
	fmt.Printf("%p\n",  &a[1])
	fmt.Printf("%p\n",  &a[2])
	fmt.Printf("%p\n",  &a[3])
	fmt.Printf("%p\n",  &a[4])
  //0xc00009a030
	//0xc00009a030
	//0xc00009a038
	//0xc00009a040
	//0xc00009a048
	//0xc00009a050
```
通过上面的声明，计算机会在内存中分配一段`连续的内存空间`给a数组。在64位机器上运行时，go的int类型数据结构占用了8个字节的空间，分配的地址是从 0xc00009a030 开始的，整个a数组在计算机内存中的分配模型如下图所示：

![](https://files.mdnice.com/user/20845/f36be40e-fca9-4c8e-9c25-da499d02e54d.png)
> ### 随机访问
>
> 这种分配连续空间的内存模型同时也揭示了数组在数据结构中的另外一个特性，即随机访问（Random Access）。随机访问这个概念在计算机科学中被定义为：**可以用同等的时间访问到一组数据中的任意一个元素**。这个特性除了和连续的内存空间模型有关以外，其实也和数组如何通过索引访问到特定的元素有关。

>> #### 疑问
>> 为什么访问数组中的第一个元素的时，索引是从0开始，即表达式是 `a[0]` ?
>> 
>> 这种**从 0 开始进行索引的编码方式被称为是“Zero-based Indexing”**，之所以采取这样的索引方式，原因在于，获取数组元素的方式是按照下面的公式进行获取的：  
` address(16进制地址)= base_address +index(索引) x data_size(数据类型占用的字节大小)` 

通过上面的例子可以看出，a这个数组被分配到初始地址是 0xc00009a030，访问第2个元素a[1] ,按照公式 可以得到0xc00009a038 这个地址。**随机访问的背后原理其实也就是利用了这个公式达到了同等的时间访问到一组数据中的任意元素**。


## 二维数组
下面是用go语言声明的一个二维数组
```go  
var a [2][3]int
	fmt.Printf("%p\n", &a)
	fmt.Printf("%p\n", &a[0])
	fmt.Printf("%p\n",  &a[0][0])
	fmt.Printf("%p\n",  &a[0][1])
	fmt.Printf("%p\n",  &a[0][2])
	fmt.Printf("%p\n",  &a[1][0])
	fmt.Printf("%p\n",  &a[1][1])
	fmt.Printf("%p\n",  &a[1][2])
  	//0xc00000a360
	//0xc00000a360
	//0xc00000a360
	//0xc00000a368
	//0xc00000a370
	//0xc00000a378
	//0xc00000a380
	//0xc00000a388
```

 在基于上面的二维数组声明的前提下，a[0][1] 这个这个元素的内存地址是多少？ 
二维数组在内存中的寻址方式有关。而这其实涉及到计算机内存到底是以`行优先（Row-Major Order）`还是以`列优先（Column-Major Order）`存储的。从运行结果上看，我的机器是行优先的。

>> #### 行优先
>>
>>行优先的内存模型保证了`每一行相邻元素都保存在了相邻的连续内存空间中`
>> 假设要访问a[i][j]的元素 ，按照下面公式：  
>> 访问地址 = `base_address + data_size(i x number_of_colunm(多少列)+j)`  
>> 内存模型图如下：
>> ![](https://files.mdnice.com/user/20845/155b40e7-01ec-4bdf-b1de-edaea67b439f.png)



>> #### 列优先
>>
>>行优先的内存模型保证了`每一列相邻元素都保存在了相邻的连续内存空间中`
>> 假设要访问a[i][j]的元素 ，按照下面公式：  
>> 访问地址 = `base_address + data_size(i x number_of_row (多少行)+j)`
>> 内存模型图如下：
>> ![](https://files.mdnice.com/user/20845/e7673348-beaf-4af3-beb8-5d97c480a43f.png)

## 多维数组
多维数组其实本质上和前面介绍的一维数组和二维数组是一样的。


## 数组的优缺点

>> ### 优点 
>> - 构建非常简单    
>> - 能在 O(1) 的时间里根据数组的下标（index）查询某个元素
>> ### 缺点
>> - 建时必须分配一段连续的空间
>> - 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）
>> - 删除和添加某个元素时，同样需要耗费 O(n) 的时间
